<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Kelly Chang,rasca0027@gmail.com"><title>Dockerize Python Web Apps · Azimuth</title><meta name="description" content="This tutorial is intended for Docker beginners. 
We will use a Django web app as an example, but it can be easily substituted with other web apps such"><meta name="keywords" content="Hexo,LeetCode,Linux,GameDesign,GameDev"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Azimuth</a></h3><div class="description"><p>Dev Diaries</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/rasca0027"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/rasca0027"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/rasca0027"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Dockerize Python Web Apps</a></h3></div><div class="post-content"><p>This tutorial is intended for Docker beginners. </p>
<p>We will use a Django web app as an example, but it can be easily substituted with other web apps such as flask, tornado, etc.</p>
<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ul>
<li>have docker installed on your local machine</li>
<li>a <code>requirements.txt</code> for all the dependencies of the app</li>
</ul>
<h2 id="Writing-the-Dockerfile"><a href="#Writing-the-Dockerfile" class="headerlink" title="Writing the Dockerfile"></a>Writing the Dockerfile</h2><h3 id="Choosing-a-base-image"><a href="#Choosing-a-base-image" class="headerlink" title="Choosing a base image"></a>Choosing a base image</h3><p>Every Dockerfile has a base image. Choosing the correct base image is important, because docker images tend to be very large in size, and can potentially cause trouble in space and be costly. Bigger images also needs more time to build.</p>
<p>If you have some time to do research, that’s good, but generally speaking I would recommend try the basic one for now, and then you can switch to a smaller one later. For example, for any python projects you can start with python:3.6, or whatever the version of python you’re using; and then after everything is working, you can switch to python:3.6-slim, or alpine. </p>
<p>At the end of this tutorial (or maybe in the next tutorial?) I will also provide a way to use multi-stage building to reduce the image size but still have what you need in the slim version.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfile</span><br><span class="line">FROM python:3.6</span><br></pre></td></tr></table></figure>
<p>Dockerfile almost always starts with the <code>FROM</code> command. The <code>FROM</code> command specifies which base image you want to build on top of. </p>
<p>Don’t forget to provide the tag, otherwise docker will automatically use <code>latest</code> as tag, and it might not be want you want. Check Docker Hub for available tags, don’t just make it up.</p>
<p>You can always use other local images as base. For example, if I already have a custom image called <code>kelly</code> locally, I can use <code>kelly:latest</code> in my Dockerfile.</p>
<h3 id="Installing-system-packages"><a href="#Installing-system-packages" class="headerlink" title="Installing system packages"></a>Installing system packages</h3><p>This step is actually optional – if you don’t need any system level packages, such as MySQL-related packages, you can skip this step.</p>
<p>It is common to use Debian/Ubuntu based images, so the first thing you would do is likely just update and install some system packages that you need with the <code>apt</code> or <code>apt-get</code> command. </p>
<p>The official python image is also Debian-based, so we can easily write something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y mysql-client</span><br></pre></td></tr></table></figure>
<p>The <code>RUN</code> command executes any provided commands in a new layer on top of the current image. </p>
<p>One thing to keep in mind is, docker images have multiple layers; the more layers, the bigger the file size. That’s why it is common to use <code>&amp;&amp;</code> to concatenate commands into one line in order to reduce layers. </p>
<h3 id="Installing-python-dependencies"><a href="#Installing-python-dependencies" class="headerlink" title="Installing python dependencies"></a>Installing python dependencies</h3><p>Now we can finally install python dependencies. I recommend a two-step method here – first copy just the <code>requirements.txt</code> and install all the dependencies, and then copy the code.</p>
<p>This might seem counter intuitive. If <code>requirements.txt</code> is part of my code, why can’t I copy everything at once? The reason is to save build time. When you’re developing, the code will change in almost every commit. Since docker is built on layers, if any layers change, all the layers on top of it need to change. This means if we copy all the code in this layer ans run <code>pip install</code> in next layer, everytime the code changes, you need to re-install everything when building a new image. What about if we reverse it? If we only install dependencies now, and then copy the code in next layer, as long as your <code>requirements.txt</code> stays the same, you don’t have to rebuild this layer again. In rapid development process, this saves a lot of time. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY requirements.txt .</span><br><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<p>The <code>COPY</code> command adds a file or directory from the host machine into the image. Here we need it to copy the <code>requirements.txt</code> to access it inside the image.</p>
<h3 id="Copy-your-code"><a href="#Copy-your-code" class="headerlink" title="Copy your code"></a>Copy your code</h3><p>We’re almost there! The next step is to copy the code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /app</span><br><span class="line">ADD . /app</span><br></pre></td></tr></table></figure>
<p>The <code>WORKDIR</code> command sets the working directory, similar to <code>cd</code> command we use in terminal.</p>
<p>The <code>ADD</code> command lets you add the whole directory to docker image. It is similar to <code>COPY</code>, but <code>ADD</code> also supports adding from an external URL. Here I’m assuming you want to add everything in current working directory on host machine into the image, thus the <code>.</code>.</p>
<h3 id="Entrypoint"><a href="#Entrypoint" class="headerlink" title="Entrypoint"></a>Entrypoint</h3><p>Now that we have everything, we just need a way to start running the app when we create a container from image. </p>
<p>Usually for web apps, it can be as simple as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;python&quot;, &quot;manage.py&quot;, &quot;runserver&quot;, &quot;0.0.0.0:8000&quot;]</span><br></pre></td></tr></table></figure></p>
<p>But of course, there are some slight improvements that can be done. For example, we should never use the <code>python manage.py runserver</code> for production. I personally use <code>gunicorn</code> instead. </p>
<p>Upon starting the server, you might also want to run some other commands too, such as migrations or create admin user accounts, etc. Therefore, I recommend writing your own <code>start.sh</code> script and calling it from Dockerfile.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;,&quot;start.sh&quot;]</span><br></pre></td></tr></table></figure></p>
<p>While my <code>start.sh</code> includes something like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># start.sh</span><br><span class="line">python manage.py migrate</span><br><span class="line">python manage.py collectstatic --noinput</span><br><span class="line">gunicorn mysite.wsgi:application --bind 0.0.0.0:8000</span><br></pre></td></tr></table></figure></p>
<p>Finally, don’t forget to expose the correct port. Since <code>gunicorn</code> is running on port 8000, I have to expose this port by:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8000</span><br></pre></td></tr></table></figure></p>
<p>Don’t worry, if you don’t want your server to listen on this port, you can map it to other ports later.</p>
<h3 id="Building-the-Image"><a href="#Building-the-Image" class="headerlink" title="Building the Image"></a>Building the Image</h3><p>Now your Dockerfile should be something like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y mysql-client</span><br><span class="line"></span><br><span class="line">COPY requirements/prod.txt .</span><br><span class="line">RUN pip install prod.txt</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;,&quot;start.sh&quot;]</span><br></pre></td></tr></table></figure></p>
<p>You can run:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;image_name&gt;:&lt;tag&gt; .</span><br></pre></td></tr></table></figure></p>
<p>If it runs successfully, you will have a docker image with the name you provided.</p>
<h2 id="Running-Docker-Containers"><a href="#Running-Docker-Containers" class="headerlink" title="Running Docker Containers"></a>Running Docker Containers</h2><p>But how do we run a container with the image we just built?</p>
<p>You need to be able to answet these questions first:</p>
<ul>
<li>What port do you want your service to run on?</li>
<li>Is there any extra file you want to add in?</li>
</ul>
<p>For example, for me, I always want my web app on run on port 80. I have a secret <code>.env</code> file that includes credentials I need which is not included in commits, which I need to add in just before the server starts. I can run the container by the below command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v ~/.env:/app/.env -p 80:8000 -t &lt;image_name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p>
<p>I like to use <code>-t</code> to show the logs before ctrl+C out of it, but you can also use <code>-d</code> for detached mode. If you do not use either, you will find yourself not able to interrupt it and will have to close the terminal, which is not ideal if you’re SSHing into other machines. </p>
<p>There are a lot of other flags that you can use, check the <a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">documentation</a> for more info.</p>
<h2 id="Final-Words"><a href="#Final-Words" class="headerlink" title="Final Words"></a>Final Words</h2><p>In the next tutorial, I will talk about how to use multi-stage building to reduce image size.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/docker/" title="docker">docker </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://rasca0027.github.io/2019/11/26/Dockerize-python-web-app/,Azimuth,Dockerize Python Web Apps,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/03/11/Tutorial-How-to-set-up-Auto-Scaling-group-with-Elastic-Load-Balancer-on-AWS/" title="[Tutorial] How to set up Auto Scaling group with Elastic Load Balancer on AWS">Next Post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>